[
  {
    "id": 1,
    "title": "Introduction to Angular",
    "content": "<h3>What is Angular?</h3><p>Angular is a popular open-source framework for building web applications. Developed and maintained by Google, it's a complete solution for creating dynamic, single-page applications (SPAs). Angular uses TypeScript, a superset of JavaScript, and follows the Model-View-Controller (MVC) architecture.</p><h3>Key Features of Angular</h3><ul><li><strong>Component-Based:</strong> Applications are built using reusable components.</li><li><strong>Two-Way Data Binding:</strong> Automatically synchronizes data between model and view.</li><li><strong>Dependency Injection:</strong> Manages dependencies efficiently.</li><li><strong>TypeScript:</strong> Provides strong typing and better tooling.</li></ul><h3>Why Use Angular?</h3><p>Angular is robust, scalable, and has a large ecosystem. It's used by companies like Google, Microsoft, and Forbes. It offers built-in tools for routing, forms, and HTTP requests, making development faster.</p><h3>Getting Started</h3><p>To start with Angular, install Node.js and the Angular CLI:</p><pre><code>npm install -g @angular/cli<br>ng new my-app<br>cd my-app<br>ng serve</code></pre><p>This sets up a basic Angular application and starts the development server.</p>"
  },
  {
    "id": 2,
    "title": "Templates and Data Binding",
    "content": "<h3>What are Templates?</h3><p>Templates in Angular are HTML files that define the view of a component. They can include Angular-specific syntax for dynamic content.</p><h3>Data Binding Types</h3><ul><li><strong>Interpolation:</strong> Displays component data in the template using {{ }}.</li><li><strong>Property Binding:</strong> Binds component properties to DOM properties using [ ].</li><li><strong>Event Binding:</strong> Listens to DOM events and calls component methods using ( ).</li><li><strong>Two-Way Binding:</strong> Combines property and event binding with [( )].</li></ul><h3>Examples</h3><p>Interpolation: <code><p>{{ title }}</p></code></p><p>Property Binding: <code><img [src]='imageUrl'></code></p><p>Event Binding: <code><button (click)='onClick()'>Click</button></code></p><p>Two-Way Binding: <code><input [(ngModel)]='name'></code></p><h3>Directives in Templates</h3><p>Directives like *ngIf and *ngFor control the structure and behavior of the DOM.</p><pre><code><div *ngIf='isVisible'>Content</div><br><ul><br> <li *ngFor='let item of items'>{{ item }}</li><br></ul></code></pre><h3>Template Reference Variables</h3><p>Use # to reference DOM elements: <code><input #myInput></code></p><h3>Best Practices</h3><p>Keep templates simple; move complex logic to the component class.</p>"
  },
  {
    "id": 3,
    "title": "Components in Angular",
    "content": "<h3>What are Components?</h3><p>Components are the fundamental building blocks of Angular applications. Each component consists of a TypeScript class, an HTML template, and optional CSS styles.</p><h3>Creating a Component</h3><p>Use the Angular CLI to generate a component:</p><pre><code>ng generate component my-component</code></pre><p>This creates files: my-component.component.ts, my-component.component.html, my-component.component.css, and my-component.component.spec.ts.</p><h3>Component Structure</h3><pre><code>import { Component } from '@angular/core';<br><br>@Component({<br> selector: 'app-my-component',<br> templateUrl: './my-component.component.html',<br> styleUrls: ['./my-component.component.css']<br>})<br>export class MyComponent {<br> title = 'Hello Angular';<br>}</code></pre><h3>Component Lifecycle</h3><p>Components have lifecycle hooks like ngOnInit, ngOnDestroy, etc.</p><h3>Input and Output</h3><p>Use @Input() to receive data from parent components and @Output() to emit events.</p><pre><code>@Input() message: string;<br>@Output() notify = new EventEmitter<string>();</code></pre><h3>Component Composition</h3><p>Components can be nested. Use the selector in templates to include them.</p><pre><code><app-child [data]='parentData'></app-child></code></pre><h3>View Encapsulation</h3><p>Angular provides ViewEncapsulation to control CSS scoping.</p><h3>Change Detection</h3><p>Angular's change detection automatically updates the view when data changes.</p>"
  },
  {
    "id": 4,
    "title": "Directives and Pipes",
    "content": "<h3>What are Directives?</h3><p>Directives are classes that add behavior to elements in Angular applications. They can modify the DOM or extend functionality.</p><h3>Types of Directives</h3><ul><li><strong>Component Directives:</strong> Have a template (e.g., custom components).</li><li><strong>Structural Directives:</strong> Change the DOM layout (e.g., *ngIf, *ngFor).</li><li><strong>Attribute Directives:</strong> Change the appearance or behavior (e.g., ngClass, ngStyle).</li></ul><h3>Built-in Directives</h3><p>*ngIf: Conditionally includes elements.</p><p>*ngFor: Repeats elements for each item in a list.</p><p>ngClass: Adds/removes CSS classes.</p><p>ngStyle: Sets inline styles.</p><h3>Custom Directives</h3><p>Create custom directives using @Directive decorator.</p><pre><code>import { Directive, ElementRef } from '@angular/core';<br><br>@Directive({<br> selector: '[appHighlight]'<br>})<br>export class HighlightDirective {<br> constructor(el: ElementRef) {<br> el.nativeElement.style.backgroundColor = 'yellow';<br> }<br>}</code></pre><h3>What are Pipes?</h3><p>Pipes transform data for display in templates. They are pure functions that take input and return output.</p><h3>Built-in Pipes</h3><ul><li>date</li><li>uppercase/lowercase</li><li>currency</li><li>json</li><li>async</li></ul><h3>Using Pipes</h3><pre><code>{{ birthday | date:'shortDate' }}</code></pre><h3>Custom Pipes</h3><p>Create with @Pipe decorator.</p><pre><code>import { Pipe, PipeTransform } from '@angular/core';<br><br>@Pipe({name: 'exponential'})<br>export class ExponentialPipe implements PipeTransform {<br> transform(value: number): number {<br> return Math.pow(value, 2);<br> }<br>}</code></pre><h3>Pure vs Impure Pipes</h3><p>Pure pipes only run when input changes; impure pipes run on every change detection cycle.</p>"
  },
  {
    "id": 5,
    "title": "Services and Dependency Injection",
    "content": "<h3>What are Services?</h3><p>Services are classes that contain business logic, data access, or utility functions. They promote reusability and separation of concerns.</p><h3>Creating a Service</h3><pre><code>ng generate service my-service</code></pre><p>This creates my-service.service.ts.</p><h3>Service Example</h3><pre><code>import { Injectable } from '@angular/core';<br><br>@Injectable({<br> providedIn: 'root'<br>})<br>export class MyService {<br> getData() {<br> return ['item1', 'item2'];<br> }<br>}</code></pre><h3>Dependency Injection</h3><p>Angular's DI system provides dependencies to components and services.</p><h3>Injecting Services</h3><p>In a component:</p><pre><code>constructor(private myService: MyService) { }</code></pre><h3>Providers</h3><p>Services can be provided at module, component, or root level.</p><h3>Singleton Services</h3><p>Services provided in root are singletons.</p><h3>HTTP Services</h3><p>Use HttpClient for API calls:</p><pre><code>import { HttpClient } from '@angular/common/http';<br><br>constructor(private http: HttpClient) { }<br><br>getPosts() {<br> return this.http.get('/api/posts');<br>}</code></pre><h3>RxJS and Observables</h3><p>Angular uses RxJS for handling asynchronous operations.</p><h3>Best Practices</h3><p>Keep services stateless; use them for data fetching and logic.</p>"
  },
  {
    "id": 6,
    "title": "Lifecycle Hooks",
    "content": "<h3>What are Lifecycle Hooks?</h3><p>Lifecycle hooks are methods that Angular calls at specific moments in a component's life, allowing you to tap into key events.</p><h3>Common Lifecycle Hooks</h3><ul><li><strong>ngOnInit:</strong> Called once after component initialization.</li><li><strong>ngOnChanges:</strong> Called when input properties change.</li><li><strong>ngDoCheck:</strong> Called during every change detection run.</li><li><strong>ngAfterContentInit:</strong> Called after content projection.</li><li><strong>ngAfterViewInit:</strong> Called after view initialization.</li><li><strong>ngOnDestroy:</strong> Called before component destruction.</li></ul><h3>Implementing Hooks</h3><p>Import interfaces from @angular/core:</p><pre><code>import { OnInit, OnDestroy } from '@angular/core';<br><br>export class MyComponent implements OnInit, OnDestroy {<br> ngOnInit() {<br> // Initialization logic<br> }<br><br> ngOnDestroy() {<br> // Cleanup logic<br> }<br>}</code></pre><h3>Use Cases</h3><ul><li>ngOnInit: Fetch data, set up subscriptions.</li><li>ngOnDestroy: Unsubscribe from observables, clean up timers.</li></ul><h3>Order of Execution</h3><p>Hooks execute in a specific order during component creation and destruction.</p><h3>Change Detection</h3><p>Some hooks relate to Angular's change detection cycle.</p><h3>Directive Lifecycle</h3><p>Directives also have lifecycle hooks.</p><h3>Best Practices</h3><p>Use ngOnInit for initialization instead of constructor for DI-resolved dependencies.</p>"
  },
  {
    "id": 7,
    "title": "Modules and NgModules",
    "content": "<h3>What are Modules?</h3><p>Modules are containers for organizing related components, directives, pipes, and services. Every Angular app has at least one module, the root module.</p><h3>NgModule Decorator</h3><p>Use @NgModule to define a module:</p><pre><code>import { NgModule } from '@angular/core';<br>import { BrowserModule } from '@angular/platform-browser';<br><br>@NgModule({<br> declarations: [AppComponent],<br> imports: [BrowserModule],<br> providers: [],<br> bootstrap: [AppComponent]<br>})<br>export class AppModule { }</code></pre><h3>Module Properties</h3><ul><li><strong>declarations:</strong> Components, directives, pipes in this module.</li><li><strong>imports:</strong> Other modules to import.</li><li><strong>exports:</strong> What to make available to other modules.</li><li><strong>providers:</strong> Services for dependency injection.</li><li><strong>bootstrap:</strong> Root component to bootstrap (only in root module).</li></ul><h3>Feature Modules</h3><p>Create feature modules to organize code:</p><pre><code>@NgModule({<br> declarations: [FeatureComponent],<br> imports: [CommonModule],<br> exports: [FeatureComponent]<br>})<br>export class FeatureModule { }</code></pre><h3>Lazy Loading</h3><p>Load modules on demand using routing.</p><h3>Shared Modules</h3><p>Modules that export commonly used directives and pipes.</p><h3>Core Module</h3><p>A module for singleton services.</p><h3>Best Practices</h3><p>Keep modules focused; use lazy loading for performance.</p>"
  },
  {
    "id": 8,
    "title": "Forms in Angular",
    "content": "<h3>Angular Forms</h3><p>Angular provides two approaches to handling forms: Template-driven and Reactive (Model-driven).</p><h3>Template-Driven Forms</h3><p>Use directives like ngModel. Import FormsModule.</p><pre><code><form #f='ngForm' (ngSubmit)='onSubmit(f)'><br> <input name='name' ngModel><br> <button type='submit'>Submit</button><br></form></code></pre><h3>Reactive Forms</h3><p>Use FormBuilder and FormGroup. Import ReactiveFormsModule.</p><pre><code>import { FormBuilder, FormGroup } from '@angular/forms';<br><br>export class MyComponent {<br> form: FormGroup;<br><br> constructor(private fb: FormBuilder) {<br> this.form = this.fb.group({<br> name: ['']<br> });<br> }<br>}</code></pre><h3>Template</h3><pre><code><form [formGroup]='form' (ngSubmit)='onSubmit()'><br> <input formControlName='name'><br></form></code></pre><h3>Validation</h3><p>Add validators to form controls:</p><pre><code>name: ['', Validators.required]</code></pre><p>Display errors: <code>*ngIf='form.get('name').invalid'</code></p><h3>Form States</h3><ul><li>pristine/dirty</li><li>touched/untouched</li><li>valid/invalid</li></ul><h3>Custom Validators</h3><p>Create functions that return validation errors.</p><h3>Dynamic Forms</h3><p>Add/remove form controls programmatically.</p><h3>Best Practices</h3><p>Use reactive forms for complex scenarios; template-driven for simple forms.</p>"
  },
  {
    "id": 9,
    "title": "Routing with Angular Router",
    "content": "<h3>What is Angular Router?</h3><p>The Angular Router enables navigation between different views or components in a single-page application.</p><h3>Setting Up Routing</h3><p>Configure routes in app-routing.module.ts:</p><pre><code>const routes: Routes = [<br> { path: '', component: HomeComponent },<br> { path: 'about', component: AboutComponent },<br> { path: 'user/:id', component: UserComponent }<br>];</code></pre><h3>RouterModule</h3><p>Import RouterModule.forRoot(routes) in AppModule.</p><h3>Navigation</h3><p>Use routerLink directive: <code><a routerLink='/about'>About</a></code></p><p>Or Router service: <code>this.router.navigate(['/about']);</code></p><h3>Route Parameters</h3><p>Access with ActivatedRoute:</p><pre><code>import { ActivatedRoute } from '@angular/router';<br><br>constructor(private route: ActivatedRoute) {<br> this.id = this.route.snapshot.paramMap.get('id');<br>}</code></pre><h3>Child Routes</h3><p>Define nested routes:</p><pre><code>{ path: 'products', component: ProductsComponent,<br> children: [<br> { path: ':id', component: ProductDetailComponent }<br> ]<br>}</code></pre><h3>Route Guards</h3><p>Protect routes with guards like CanActivate.</p><pre><code>canActivate(route: ActivatedRouteSnapshot): boolean {<br> return this.authService.isLoggedIn();<br>}</code></pre><h3>Lazy Loading</h3><p>Load modules on navigation: <code>loadChildren: () => import('./feature/feature.module').then(m => m.FeatureModule)</code></p><h3>Router Events</h3><p>Listen to navigation events.</p><h3>Best Practices</h3><p>Use lazy loading; implement guards for security.</p>"
  }
]
