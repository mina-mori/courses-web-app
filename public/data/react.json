[
  {
    "id": 1,
    "title": "Introduction to React",
    "content": "<h3>What is React?</h3><p>React is a popular JavaScript library for building user interfaces, particularly for web applications. It was developed by Facebook and is now maintained by a community of developers. React allows you to create reusable UI components that manage their own state, making it easier to build complex, interactive web apps.</p><h3>Key Features of React</h3><ul><li><strong>Component-Based:</strong> Build encapsulated components that manage their own state.</li><li><strong>Virtual DOM:</strong> React uses a virtual representation of the DOM for efficient updates.</li><li><strong>Declarative:</strong> Describe what the UI should look like, and React handles the rendering.</li><li><strong>JSX:</strong> A syntax extension that allows you to write HTML-like code in JavaScript.</li></ul><h3>Why Use React?</h3><p>React is fast, scalable, and has a large ecosystem. It's used by companies like Netflix, Airbnb, and Instagram. It promotes reusable code and makes debugging easier with tools like React DevTools.</p><h3>Getting Started</h3><p>To start with React, you need Node.js installed. Use Create React App to bootstrap a new project:</p><pre><code>npx create-react-app my-app<br>cd my-app<br>npm start</code></pre><p>This will set up a basic React application.</p>"
  },
  {
    "id": 2,
    "title": "JSX: JavaScript XML",
    "content": "<h3>What is JSX?</h3><p>JSX is a syntax extension for JavaScript that allows you to write HTML-like code within JavaScript. It's not required for React, but it's highly recommended as it makes code more readable and easier to write.</p><h3>Basic JSX Syntax</h3><p>JSX looks like HTML but is actually JavaScript. For example:</p><pre><code>const element = <h1>Hello, World!</h1>;</code></pre><p>You can embed JavaScript expressions in JSX using curly braces:</p><pre><code>const name = 'John';<br>const element = <h1>Hello, {name}!</h1>;</code></pre><h3>JSX Rules</h3><ul><li>JSX must have one parent element.</li><li>Use className instead of class for CSS classes.</li><li>Self-closing tags must end with />.</li><li>JavaScript expressions go in {}.</li></ul><h3>Rendering JSX</h3><p>To render JSX, use ReactDOM.render():</p><pre><code>ReactDOM.render(element, document.getElementById('root'));</code></pre><p>This renders the JSX element into the DOM.</p><h3>JSX vs HTML</h3><p>While JSX resembles HTML, there are differences: attribute names (e.g., className vs class), and JSX is compiled to JavaScript function calls.</p>"
  },
  {
    "id": 3,
    "title": "Components in React",
    "content": "<h3>What are Components?</h3><p>Components are the building blocks of React applications. They are reusable pieces of code that return JSX elements. Components can be functions or classes.</p><h3>Function Components</h3><p>The simplest way to define a component is as a function:</p><pre><code>function Welcome(props) {<br> return <h1>Hello, {props.name}!</h1>;<br>}</code></pre><p>Function components are stateless by default but can use hooks for state.</p><h3>Class Components</h3><p>Class components extend React.Component:</p><pre><code>class Welcome extends React.Component {<br> render() {<br> return <h1>Hello, {this.props.name}!</h1>;<br> }<br>}</code></pre><p>Class components can have state and lifecycle methods.</p><h3>Rendering Components</h3><p>To render a component, use it like an HTML tag:</p><pre><code>ReactDOM.render(<Welcome name='Sara' />, document.getElementById('root'));</code></pre><h3>Component Composition</h3><p>Components can be nested inside each other:</p><pre><code>function App() {<br> return (<br> <div><br> <Welcome name='Sara' /><br> <Welcome name='Cahal' /><br> </div><br> );<br>}</code></pre><p>This promotes reusability and modularity.</p><h3>Props</h3><p>Props are how data is passed to components. They are read-only.</p><pre><code>function Welcome(props) {<br> return <h1>Hello, {props.name}!</h1>;<br>}</code></pre><p>You can pass any JavaScript value as a prop, including objects and functions.</p>"
  },
  {
    "id": 4,
    "title": "State and Props",
    "content": "<h3>Understanding Props</h3><p>Props (short for properties) are how data is passed from parent to child components. They are immutable and should not be changed by the child component.</p><h3>Passing Props</h3><pre><code>function ChildComponent(props) {<br> return <p>{props.message}</p>;<br>}<br><br>function ParentComponent() {<br> return <ChildComponent message='Hello from parent' />;<br>}</code></pre><h3>Default Props</h3><p>You can set default values for props:</p><pre><code>ChildComponent.defaultProps = {<br> message: 'Default message'<br>};</code></pre><h3>Prop Types</h3><p>Use PropTypes to validate props:</p><pre><code>import PropTypes from 'prop-types';<br><br>ChildComponent.propTypes = {<br> message: PropTypes.string.isRequired<br>};</code></pre><h3>Understanding State</h3><p>State is a way to store and manage data that can change over time within a component. Unlike props, state is mutable.</p><h3>Using State in Class Components</h3><pre><code>class Counter extends React.Component {<br> constructor(props) {<br> super(props);<br> this.state = { count: 0 };<br> }<br><br> render() {<br> return <p>Count: {this.state.count}</p>;<br> }<br>}</code></pre><h3>Updating State</h3><p>Use setState to update state:</p><pre><code>this.setState({ count: this.state.count + 1 });</code></pre><p>setState is asynchronous, so don't rely on current state for updates.</p><h3>State in Function Components</h3><p>Use the useState hook:</p><pre><code>import { useState } from 'react';<br><br>function Counter() {<br> const [count, setCount] = useState(0);<br><br> return <p>Count: {count}</p>;<br>}</code></pre><h3>When to Use State vs Props</h3><p>Use props for data passed from parent. Use state for data that changes within the component.</p>"
  },
  {
    "id": 5,
    "title": "Event Handling in React",
    "content": "<h3>Handling Events</h3><p>React events are similar to DOM events but with some differences. Event handlers are camelCased and passed as functions.</p><h3>Basic Event Handling</h3><pre><code>function Button() {<br> function handleClick() {<br> alert('Button clicked!');<br> }<br><br> return <button onClick={handleClick}>Click me</button>;<br>}</code></pre><h3>Passing Arguments to Event Handlers</h3><p>Use arrow functions or bind:</p><pre><code><button onClick={() => handleClick(id)}>Click</button></code></pre><p>Or bind in constructor for class components.</p><h3>Event Object</h3><p>The event object is passed automatically:</p><pre><code>function handleClick(e) {<br> e.preventDefault();<br> console.log('Button clicked');<br>}</code></pre><h3>Synthetic Events</h3><p>React uses SyntheticEvent, a cross-browser wrapper around the native event.</p><h3>Common Events</h3><ul><li>onClick</li><li>onChange</li><li>onSubmit</li><li>onMouseOver</li><li>onKeyDown</li></ul><h3>Preventing Default Behavior</h3><p>Use e.preventDefault() to stop default actions, like form submission.</p><h3>Conditional Rendering Based on Events</h3><p>Events can trigger state changes that affect rendering.</p>"
  },
  {
    "id": 6,
    "title": "Lifecycle Methods in Class Components",
    "content": "<h3>What are Lifecycle Methods?</h3><p>Lifecycle methods are special methods in class components that run at different stages of a component's life.</p><h3>Mounting Phase</h3><ul><li><strong>constructor():</strong> Called before the component mounts.</li><li><strong>render():</strong> Returns the JSX to render.</li><li><strong>componentDidMount():</strong> Called after the component mounts. Good for API calls.</li></ul><h3>Updating Phase</h3><ul><li><strong>shouldComponentUpdate():</strong> Determines if re-render is needed.</li><li><strong>render():</strong> Re-renders the component.</li><li><strong>componentDidUpdate():</strong> Called after update. Can cause side effects.</li></ul><h3>Unmounting Phase</h3><ul><li><strong>componentWillUnmount():</strong> Called before unmounting. Clean up subscriptions.</li></ul><h3>Error Handling</h3><ul><li><strong>componentDidCatch():</strong> Catches errors in child components.</li></ul><h3>Example</h3><pre><code>class MyComponent extends React.Component {<br> componentDidMount() {<br> console.log('Component mounted');<br> }<br><br> componentWillUnmount() {<br> console.log('Component will unmount');<br> }<br><br> render() {<br> return <div>Hello</div>;<br> }<br>}</code></pre><h3>Note on Hooks</h3><p>In function components, useEffect replaces most lifecycle methods.</p>"
  },
  {
    "id": 7,
    "title": "React Hooks",
    "content": "<h3>What are Hooks?</h3><p>Hooks are functions that let you use state and lifecycle features in function components. They were introduced in React 16.8.</p><h3>useState Hook</h3><p>Allows adding state to function components:</p><pre><code>import { useState } from 'react';<br><br>function Counter() {<br> const [count, setCount] = useState(0);<br><br> return (<br> <div><br> <p>Count: {count}</p><br> <button onClick={() => setCount(count + 1)}>Increment</button><br> </div><br> );<br>}</code></pre><h3>useEffect Hook</h3><p>Handles side effects like API calls:</p><pre><code>import { useEffect } from 'react';<br><br>useEffect(() => {<br> document.title = Count: ${count};<br>}, [count]);</code></pre><p>The second argument is the dependency array.</p><h3>useContext Hook</h3><p>Accesses context values:</p><pre><code>const value = useContext(MyContext);</code></pre><h3>useReducer Hook</h3><p>Manages complex state logic:</p><pre><code>const [state, dispatch] = useReducer(reducer, initialState);</code></pre><h3>Custom Hooks</h3><p>You can create your own hooks by combining existing ones.</p><h3>Rules of Hooks</h3><ul><li>Only call hooks at the top level.</li><li>Only call hooks from React functions.</li></ul><h3>Migration from Class Components</h3><p>Hooks allow function components to do everything class components can.</p>"
  },
  {
    "id": 8,
    "title": "Context API",
    "content": "<h3>What is Context?</h3><p>Context provides a way to pass data through the component tree without prop drilling.</p><h3>Creating Context</h3><pre><code>const MyContext = React.createContext(defaultValue);</code></pre><h3>Provider</h3><p>Wrap components with Provider to provide the value:</p><pre><code><MyContext.Provider value={someValue}><br> <ChildComponent /><br></MyContext.Provider></code></pre><h3>Consumer</h3><p>Use Consumer to access the value:</p><pre><code><MyContext.Consumer><br> {value => <p>{value}</p>}<br></MyContext.Consumer></code></pre><h3>useContext Hook</h3><p>In function components, use useContext:</p><pre><code>const value = useContext(MyContext);</code></pre><h3>When to Use Context</h3><p>Use for global data like themes, user info, or language settings. Avoid overusing; props are preferable for local data.</p><h3>Example</h3><pre><code>const ThemeContext = React.createContext('light');<br><br>function App() {<br> return (<br> <ThemeContext.Provider value='dark'><br> <Toolbar /><br> </ThemeContext.Provider><br> );<br>}<br><br>function Toolbar() {<br> return <ThemedButton />;<br>}<br><br>function ThemedButton() {<br> const theme = useContext(ThemeContext);<br> return <button className={theme}>Button</button>;<br>}</code></pre><h3>Dynamic Context</h3><p>Context can be updated by changing the Provider's value.</p>"
  },
  {
    "id": 9,
    "title": "Routing with React Router",
    "content": "<h3>What is React Router?</h3><p>React Router is a library for routing in React applications. It allows navigation between different components.</p><h3>Installation</h3><pre><code>npm install react-router-dom</code></pre><h3>Basic Routing</h3><pre><code>import { BrowserRouter, Route, Switch } from 'react-router-dom';<br><br>function App() {<br> return (<br> <BrowserRouter><br> <Switch><br> <Route exact path='/' component={Home} /><br> <Route path='/about' component={About} /><br> </Switch><br> </BrowserRouter><br> );<br>}<br></code></pre><h3>Link Component</h3><p>Use Link for navigation:</p><pre><code>import { Link } from 'react-router-dom';<br><br><Link to='/about'>About</Link></code></pre><h3>URL Parameters</h3><p>Access params with useParams:</p><pre><code>import { useParams } from 'react-router-dom';<br><br>function User() {<br> const { id } = useParams();<br> return <p>User ID: {id}</p>;<br>}</code></pre><h3>Nested Routes</h3><p>Routes can be nested inside components.</p><h3>Redirect</h3><p>Use Redirect to programmatically navigate:</p><pre><code>import { Redirect } from 'react-router-dom';<br><br>if (!loggedIn) return <Redirect to='/login' />;</code></pre><h3>Protected Routes</h3><p>Create components that check authentication before rendering.</p><h3>History Object</h3><p>Use useHistory for programmatic navigation:</p><pre><code>const history = useHistory();<br>history.push('/dashboard');</code></pre>"
  }
]
