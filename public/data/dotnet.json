[
  {
    "id": 1,
    "title": "Introduction to ASP.NET Core",
    "content": "<h3>What is ASP.NET Core?</h3><p>ASP.NET Core is a cross-platform, high-performance framework for building modern, cloud-based, internet-connected applications. Developed by Microsoft, it's the successor to ASP.NET and runs on .NET Core, allowing deployment on Windows, Linux, and macOS.</p><h3>Key Features of ASP.NET Core</h3><ul><li><strong>Cross-Platform:</strong> Runs on multiple operating systems.</li><li><strong>Modular:</strong> Only includes necessary components in your app.</li><li><strong>High Performance:</strong> Optimized for speed and scalability.</li><li><strong>Dependency Injection:</strong> Built-in support for DI.</li></ul><h3>Why Use ASP.NET Core?</h3><p>ASP.NET Core is used by companies like Stack Overflow, GoDaddy, and Microsoft itself. It supports MVC, Web API, Razor Pages, and more, making it versatile for web development.</p><h3>Getting Started</h3><p>To start with ASP.NET Core, install the .NET SDK:</p><pre><code>dotnet new webapp -n MyApp<br>cd MyApp<br>dotnet run</code></pre><p>This creates a basic web application and starts the development server.</p>"
  },
  {
    "id": 2,
    "title": "MVC Pattern in ASP.NET Core",
    "content": "<h3>What is MVC?</h3><p>MVC (Model-View-Controller) is a design pattern that separates an application into three main components: Model (data), View (UI), and Controller (logic).</p><h3>Model</h3><p>Represents the data and business logic. In ASP.NET Core, models are C# classes.</p><pre><code>public class Product<br>{<br> public int Id { get; set; }<br> public string Name { get; set; }<br>}</code></pre><h3>View</h3><p>Handles the UI. In ASP.NET Core MVC, views are Razor files (.cshtml) that combine HTML and C#.</p><pre><code>@model Product<br><h1>@Model.Name</h1></code></pre><h3>Controller</h3><p>Handles user input and interactions. Controllers are C# classes that inherit from Controller.</p><pre><code>public class ProductsController : Controller<br>{<br> public IActionResult Index()<br> {<br> return View();<br> }<br>}</code></pre><h3>Request Flow</h3><p>Requests go to the controller, which interacts with the model and returns a view.</p><h3>Advantages</h3><p>Separation of concerns, testability, and maintainability.</p><h3>Razor Pages Alternative</h3><p>ASP.NET Core also supports Razor Pages, which combine view and controller logic.</p>"
  },
  {
    "id": 3,
    "title": "Controllers and Actions",
    "content": "<h3>What are Controllers?</h3><p>Controllers in ASP.NET Core MVC are classes that handle HTTP requests. They contain action methods that process requests and return responses.</p><h3>Creating a Controller</h3><p>Use the MVC Controller template or create manually:</p><pre><code>using Microsoft.AspNetCore.Mvc;<br><br>public class HomeController : Controller<br>{<br> public IActionResult Index()<br> {<br> return View();<br> }<br>}</code></pre><h3>Action Methods</h3><p>Actions return IActionResult or specific types like ViewResult, JsonResult.</p><pre><code>public IActionResult About()<br>{<br> ViewData['Message'] = 'Your application description page.';<br> return View();<br>}</code></pre><h3>Routing to Actions</h3><p>Routes map URLs to actions. Configured in Startup.cs or with attributes.</p><pre><code>[Route('api/[controller]')]<br>public class ProductsController : ControllerBase<br>{<br> [HttpGet]<br> public IEnumerable<Product> Get() { ... }<br>}</code></pre><h3>Parameters</h3><p>Actions can take parameters from route, query string, or body.</p><pre><code>public IActionResult Details(int id) { ... }</code></pre><h3>Filters</h3><p>Use filters for cross-cutting concerns like authorization or logging.</p><h3>Asynchronous Actions</h3><p>Use async/await for non-blocking operations.</p><pre><code>public async Task<IActionResult> Index() { ... }</code></pre><h3>Best Practices</h3><p>Keep controllers thin; move logic to services.</p>"
  },
  {
    "id": 4,
    "title": "Models and Data Binding",
    "content": "<h3>What are Models?</h3><p>Models represent the data in your application. They can be simple POCO classes or complex with validation.</p><h3>Data Binding</h3><p>ASP.NET Core automatically binds request data to model properties.</p><h3>Model Binding Sources</h3><ul><li>Form data</li><li>Route parameters</li><li>Query strings</li><li>Request body (JSON)</li></ul><h3>Example</h3><pre><code>public class CreateProductViewModel<br>{<br> [Required]<br> public string Name { get; set; }<br> [Range(0, 1000)]<br> public decimal Price { get; set; }<br>}<br><br>[HttpPost]<br>public IActionResult Create(CreateProductViewModel model)<br>{<br> if (ModelState.IsValid)<br> {<br> // Save to database<br> return RedirectToAction('Index');<br> }<br> return View(model);<br>}</code></pre><h3>Validation</h3><p>Use data annotations or custom validators.</p><h3>View Models</h3><p>Separate models for views to avoid over-posting.</p><h3>Model State</h3><p>Check ModelState.IsValid to ensure data integrity.</p><h3>Custom Model Binders</h3><p>Create for complex binding scenarios.</p><h3>Best Practices</h3><p>Validate input; use view models for security.</p>"
  },
  {
    "id": 5,
    "title": "Views and Razor Syntax",
    "content": "<h3>What are Views?</h3><p>Views are the UI templates in ASP.NET Core MVC. They use Razor syntax to embed C# code in HTML.</p><h3>Razor Syntax</h3><p>Use @ for C# expressions:</p><pre><code><h1>@Model.Title</h1></code></pre><p>Multi-line code with @{ }:</p><pre><code>@{<br> var message = 'Hello';<br>}<br><p>@message</p></code></pre><h3>Layout Views</h3><p>Use _Layout.cshtml for shared UI:</p><pre><code><!DOCTYPE html><br><html><br><head><br> <title>@ViewData['Title']</title><br></head><br><body><br> @RenderBody()<br></body><br></html></code></pre><h3>Partial Views</h3><p>Reusable view components: @Html.Partial('_PartialView')</p><h3>Tag Helpers</h3><p>Server-side helpers for HTML elements:</p><pre><code><a asp-controller='Home' asp-action='Index'>Home</a></code></pre><h3>View Components</h3><p>Reusable UI logic, similar to partial views but with C# classes.</p><h3>Conditional Rendering</h3><pre><code>@if (Model.IsActive)<br>{<br> <p>Active</p><br>}</code></pre><h3>Loops</h3><pre><code>@foreach (var item in Model.Items)<br>{<br> <li>@item.Name</li><br>}</code></pre><h3>Best Practices</h3><p>Keep views simple; use view models.</p>"
  },
  {
    "id": 6,
    "title": "Middleware in ASP.NET Core",
    "content": "<h3>What is Middleware?</h3><p>Middleware are components that handle requests and responses in the ASP.NET Core pipeline. They form a chain where each can process, modify, or short-circuit the request.</p><h3>Request Pipeline</h3><p>Requests flow through middleware in order: Authentication → Routing → Authorization → etc.</p><h3>Built-in Middleware</h3><ul><li>UseStaticFiles: Serves static files.</li><li>UseRouting: Enables routing.</li><li>UseAuthorization: Handles authorization.</li><li>UseEndpoints: Maps routes to endpoints.</li></ul><h3>Custom Middleware</h3><p>Create by implementing IMiddleware or using RequestDelegate.</p><pre><code>public class LoggingMiddleware<br>{<br> private readonly RequestDelegate _next;<br><br> public LoggingMiddleware(RequestDelegate next)<br> {<br> _next = next;<br> }<br><br> public async Task InvokeAsync(HttpContext context)<br> {<br> // Log request<br> await _next(context);<br> // Log response<br> }<br>}</code></pre><h3>Registering Middleware</h3><p>In Startup.cs:</p><pre><code>app.UseMiddleware<LoggingMiddleware>();</code></pre><h3>Order Matters</h3><p>Middleware order affects behavior. UseRouting before UseEndpoints.</p><h3>Short-Circuiting</h3><p>Middleware can end the pipeline early.</p><h3>Exception Handling</h3><p>UseExceptionHandler middleware for global error handling.</p><h3>Best Practices</h3><p>Keep middleware focused; test thoroughly.</p>"
  },
  {
    "id": 7,
    "title": "Dependency Injection",
    "content": "<h3>What is Dependency Injection?</h3><p>DI is a design pattern where dependencies are injected into a class rather than created inside it. ASP.NET Core has built-in DI container.</p><h3>Service Lifetimes</h3><ul><li><strong>Transient:</strong> New instance each time.</li><li><strong>Scoped:</strong> One instance per request.</li><li><strong>Singleton:</strong> One instance for the app lifetime.</li></ul><h3>Registering Services</h3><p>In Startup.cs:</p><pre><code>services.AddTransient<IMyService, MyService>();</code></pre><h3>Injecting Dependencies</h3><p>In constructors:</p><pre><code>public class HomeController : Controller<br>{<br> private readonly IMyService _myService;<br><br> public HomeController(IMyService myService)<br> {<br> _myService = myService;<br> }<br>}</code></pre><h3>Built-in Services</h3><p>ASP.NET Core registers many services like ILogger, IConfiguration.</p><h3>Custom Services</h3><p>Create interfaces and implementations.</p><pre><code>public interface IProductService<br>{<br> IEnumerable<Product> GetAll();<br>}<br><br>public class ProductService : IProductService<br>{<br> // Implementation<br>}</code></pre><h3>Options Pattern</h3><p>Inject configuration:</p><pre><code>services.Configure<MyOptions>(Configuration.GetSection('MyOptions'));</code></pre><h3>Best Practices</h3><p>Use interfaces; choose appropriate lifetimes.</p>"
  },
  {
    "id": 8,
    "title": "Entity Framework Core",
    "content": "<h3>What is Entity Framework Core?</h3><p>EF Core is an ORM (Object-Relational Mapper) for .NET that enables working with databases using .NET objects. It's lightweight and cross-platform.</p><h3>DbContext</h3><p>The main class for interacting with the database:</p><pre><code>public class AppDbContext : DbContext<br>{<br> public DbSet<Product> Products { get; set; }<br><br> protected override void OnConfiguring(DbContextOptionsBuilder options)<br> {<br> options.UseSqlServer(_connectionString);<br> }<br>}</code></pre><h3>Code-First Approach</h3><p>Define models first, then generate database schema.</p><h3>Migrations</h3><p>Manage database schema changes:</p><pre><code>dotnet ef migrations add InitialCreate<br>dotnet ef database update</code></pre><h3>Querying Data</h3><pre><code>var products = await _context.Products.ToListAsync();</code></pre><h3>LINQ Support</h3><p>Use LINQ for queries:</p><pre><code>var expensiveProducts = _context.Products.Where(p => p.Price > 100);</code></pre><h3>Relationships</h3><p>Define one-to-many, many-to-many with navigation properties.</p><h3>Async Operations</h3><p>Use async methods for non-blocking database access.</p><h3>Best Practices</h3><p>Use repositories; avoid N+1 queries; use AsNoTracking for read-only.</p>"
  },
  {
    "id": 9,
    "title": "Routing in ASP.NET Core",
    "content": "<h3>What is Routing?</h3><p>Routing maps incoming requests to appropriate controller actions or endpoints in ASP.NET Core.</p><h3>Conventional Routing</h3><p>Defined in Startup.cs:</p><pre><code>app.UseEndpoints(endpoints =><br>{<br> endpoints.MapControllerRoute(<br> name: 'default',<br> pattern: '{controller=Home}/{action=Index}/{id?}');<br>});</code></pre><h3>Attribute Routing</h3><p>Use attributes on controllers/actions:</p><pre><code>[Route('api/[controller]')]<br>public class ProductsController : ControllerBase<br>{<br> [HttpGet('{id}')]<br> public Product Get(int id) { ... }<br>}</code></pre><h3>Route Parameters</h3><p>Capture values from URL:</p><pre><code>[HttpGet('products/{category}/{id}')]<br>public IActionResult GetProduct(string category, int id) { ... }</code></pre><h3>Route Constraints</h3><p>Restrict parameter types: {id:int}</p><h3>Area Routing</h3><p>Organize large apps with areas.</p><h3>Endpoint Routing</h3><p>Modern routing system in ASP.NET Core 3+.</p><h3>Custom Route Handlers</h3><p>Create for advanced scenarios.</p><h3>Link Generation</h3><p>Use UrlHelper to generate URLs.</p><h3>Best Practices</h3><p>Use attribute routing for APIs; keep routes RESTful.</p>"
  }
]
